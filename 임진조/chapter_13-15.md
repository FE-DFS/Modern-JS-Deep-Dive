# 스코프

스코프: 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙
식별자 결정: 어떤 변수를 참조해야 하는지 결정
렉시컬 환경: 코드가 어디서 실행되며 주변에 어떤 코드가 있는지 -> 문맥
전역 스코프: 코드의 가장 바깥 영역
지역 스코프: 함수 몸체 내부

## 스코프 체인

함수의 중첩: 함수 몸체 내부에서 함수가 정의된 것
함수 중첩에의해 계층적 구조를 가진다
inner 지역 -> outer 지역 -> 전역 순으로 체인이 일어난다
스코프 체인을 통해 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.

## 함수레벨 스코프

함수 내부에서 스코프 생성
if, while, for문 등 에서는 지역 스코프로 인식하지 않음

## 렉시컬 스코프

함수의 정의 위치에 따라 스코프를 결정

## 변수의 생명 주기

함수의 경우: 함수가 생성될 떄 매개변수가 생성되고 종료될때 제거된다.
함수에서는 변수 호이스팅이 함수 단위로 일어난다

## 전역 변수의 문제점

암묵적 결함: 모든 코드가 전역 변수를 참조하고 변경 가능
생명주기가 길어지면 메모리 리소스도 오래 잡아먹고 모든 곳에서 접근이 가능하기 때문에 좋지못하다
스코프 체인에서 가장 상위에 존재하기 때문에 가장 늦게 접근된다. 따라서 검색속도가 가장 느림

## 모듈패턴

위의 문제점을 해결하기 위한 패턴
클로저를 이용하려 캡슐화하고 전역변수를 억제한다.

ES6로 오면서 모듈이 생겼다.

```html
<script type="module" src="lib.mjs"></script>
```

하지만 webpack사용을 권장

# let, const

var 키워드는 변수 중복을 허용한다

```js
var x = 1;
var x = 100; // 100
```

함수 레벨 스코프

```js
var x = 1;
if (true) {
  var x = 10;
}

console.log(x); // 10 함수 내부가 아니면 모두 전역변수
```

## let

변수 중복선언 금지
블록레벨 스코프: {} 기준으로 스코프를 가짐
let 변수는 선언과 초기화를 분리하여 진행하기 때문에 선언 전에 참조할 수 없다
선언 단계는 호이스팅 하지만 초기화 단계는 런타임에 실행하기 때문에 일시적 사각지대TDZ 발생
암묵적 전역 객체는 window객체에 속한다
let 키워드는 전역 객체의 프로퍼티가 아니다

## const

let과 마찬가지로 블록레벨 스코프프
const로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.
재할당 금지변수 이다
일반적으로 상수는 대문자와 언더스코어로 적는게 일반적이다
