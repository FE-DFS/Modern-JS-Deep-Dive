# 브라우저 렌더링 과정

- 파싱
  - 파싱(구문 분석): 문법에 맞게 작성된 텍스트 문서를 읽어 들여 문서의 문자열을 토큰으로 분해하고, 토큰에 문법적 의미와 구조를 반영하여 파싱 트리를 생성하는 과정
- 렌더링
  - HTML, CSS, JavaScript 파싱 후 브라우저에 시각적으로 출력하는 과정
  1.  서버로부터 리소스를 요청하고 서버로부터 응답을 받음
  2.  브라우저의 렌더링 엔진은 HTML을 파싱하여 DOM을 생성하고, CSS를 파싱하여 CSSOM을 생성함
  3.  서버로 부터 받은 자바스크립트 파일을 파싱하여 AST를 생성하고 바이트코드로 변환하여 실행 이때 DOM API를 사용하여 DOM이나 CSSOM을 변경할 수 있음 변경된 DOM과 CSSOM은 렌더링 트리로 결합됨
  4.  렌더링 트리는 브라우저 화면에 표시되는 노드의 집합체
  5.  렌더링 트리를 기반으로 브라우저는 레이아웃을 생성하고 픽셀을 렌더링함

## URL의 구성 요소

https://www.example.com:443/path/to/resource?name=value&id=123#section
scheme: https
host: www.example.com  
port: 443
path: /path/to/resource
query: name=value&id=123
fragment: section

# HTML 파싱과 DOM 생성

1. 서버로부터 HTML 문서를 받아옴

   - 브라우저가 서버에 HTML 문서를 요청
   - 서버는 HTML 문서를 바이트(2진수) 형태로 응답

2. 바이트 → 문자 변환

   - 메타 태그의 charset 어트리뷰트에 지정된 인코딩 방식(ex: UTF-8)을 기준으로 문자열로 변환
   - <meta charset="UTF-8">

3. 토큰화

   - 문자열을 의미있는 최소 단위인 토큰으로 분해
   - 시작 태그, 종료 태그, 속성, 텍스트 등으로 분류

4. 토큰을 객체로 변환하여 노드 생성

   - HTML 요소는 요소 노드로 변환
   - 텍스트는 텍스트 노드로 변환
   - 주석은 주석 노드로 변환

5. DOM 트리 구축

   - 생성된 노드들을 트리 자료구조로 구성
   - HTML 요소 간의 부모-자식 관계를 반영하여 계층적 구조 형성
   - 모든 노드들이 연결되어 DOM 트리 완성

6. DOM 완성
   - 파싱이 완료되면 DOM이라는 객체 구조가 완성됨
   - JavaScript에서 DOM API를 통해 DOM을 조작할 수 있게 됨

## CSS 파싱과 CSSOM 생성

1. CSS 로딩

   - HTML을 파싱하다가 CSS를 로드하는 link 태그나 style 태그를 만나면 CSS 파싱 시작
   - 외부 CSS 파일은 서버에서 다운로드

2. 바이트 → 문자 변환

   - CSS 파일을 문자열로 변환
   - HTML과 동일한 과정 수행

3. 토큰화

   - CSS 문자열을 의미있는 단위로 분해
   - 선택자, 속성, 값 등으로 분류

4. 노드 생성

   - 토큰을 파싱하여 스타일 규칙 노드 생성
   - 선택자와 해당하는 스타일 선언 블록으로 구성

5. CSSOM 트리 구축

   - 노드들을 트리 구조로 구성
   - CSS의 상속 관계를 반영
   - 스타일 규칙의 우선순위 고려

6. CSSOM 완성
   - 파싱이 완료되면 CSSOM이라는 객체 구조 완성
   - DOM에 적용될 스타일 정보를 포함
   - JavaScript에서 CSSOM API로 접근 가능

위 단계는 다음과 같을 떄 재실행된다

- 자바스크립트에서 DOM API를 사용하여 DOM을 변경하는 경우
- 자바스크립트에서 CSSOM API를 사용하여 CSSOM을 변경하는 경우
- 브라우저 크기를 조정하는 경우
- 뷰포트 크기를 조정하는 경우
- 미디어 쿼리를 통해 반응형 웹 디자인을 적용하는 경우
- 자바스크립트에서 새로운 스타일을 동적으로 추가하는 경우

## 자바스크립트 파싱과 실행

1. 토크나이징(어휘 분석)

   - 자바스크립트 코드를 최소 단위인 토큰으로 분해
   - 예: 키워드, 식별자, 연산자, 구분자 등으로 분류
   - let name = "홍길동" → let(키워드), name(식별자), =(연산자), "홍길동"(문자열) 등으로 분해

2. 파싱(구문 분석)

   - 토큰들을 문법적 의미와 구조에 따라 AST(추상 구문 트리)로 변환
   - AST는 프로그램의 구조를 트리 형태로 표현
   - 문법 오류가 있다면 이 단계에서 발견됨
   - 변수 선언, 할당, 함수 정의 등의 구조가 트리 형태로 구성됨

3. 바이트코드 생성과 실행
   - AST를 기반으로 바이트코드 생성
   - 자바스크립트 엔진이 바이트코드를 실행
   - V8 엔진의 경우:
     - 인터프리터(Ignition)가 바이트코드를 생성하고 실행
     - 자주 실행되는 코드는 컴파일러(TurboFan)가 최적화된 기계어로 컴파일
   - 실행 과정에서 변수나 함수는 실행 컨텍스트에 저장되어 관리됨

## 리플로우와 리페인트

1. 리플로우(Reflow)

   - 레이아웃 계산을 다시 하는 과정
   - DOM 요소의 크기나 위치가 변경될 때 발생
   - 변경된 요소와 그 자식 요소들의 레이아웃을 재계산
   - 성능에 큰 영향을 미치므로 최소화하는 것이 좋음

   리플로우가 발생하는 경우:

   - DOM 요소 추가/삭제
   - DOM 요소의 크기/위치 변경
   - 윈도우 리사이징
   - 폰트 변경
   - 스크롤

2. 리페인트(Repaint)

   - 화면을 다시 그리는 과정
   - 시각적 속성이 변경될 때 발생
   - 레이아웃에는 영향을 주지 않음

   리페인트가 발생하는 경우:

   - 색상 변경
   - 배경 이미지 변경
   - 투명도 변경
   - outline 변경

3. 최적화 방법
   - CSS 클래스 변경을 한 번에 처리
   - position: absolute/fixed 사용하여 레이아웃 영향 최소화
   - 애니메이션에 transform 사용
   - requestAnimationFrame() 사용하여 렌더링 최적화

## async, defer

HTML 파싱 중 script 태그를 만나면 HTML 파싱이 중단되고 자바스크립트 파일을 로드하고 실행합니다. 이를 방지하기 위해 async와 defer 속성을 사용할 수 있습니다.

1. 일반적인 script 태그

   - HTML 파싱 중단
   - 스크립트 다운로드 및 실행
   - 실행 완료 후 HTML 파싱 재개

   ```html
   <script src="app.js"></script>
   ```

2. async 속성

   - HTML 파싱과 스크립트 다운로드가 병렬로 진행
   - 스크립트 다운로드 완료 시 HTML 파싱 중단하고 스크립트 실행
   - 실행 순서가 보장되지 않음 (로드가 완료되는 순서대로 실행)
   - DOM이 완성되기 전에 실행될 수 있음

   ```html
   <script async src="app.js"></script>
   ```

3. defer 속성
   - HTML 파싱과 스크립트 다운로드가 병렬로 진행
   - HTML 파싱이 완료된 후 스크립트 실행
   - 실행 순서가 보장됨 (선언된 순서대로 실행)
   - DOM이 완성된 후 실행됨
   ```html
   <script defer src="app.js"></script>
   ```

사용 권장사항:

- async: 다른 스크립트에 의존성이 없는 독립적인 스크립트
- defer: DOM이나 다른 스크립트에 의존성이 있는 스크립트
