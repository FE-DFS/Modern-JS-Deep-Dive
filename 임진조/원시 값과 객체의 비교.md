# 11 원시값과 객체 비교

원시타입의 값: 변경 불가능, 할당할 경우 실제값을 메모리에 할당, 다른 변수에 할당할 경우 값에 의한 전달
객체타입의 값: 변경 가능, 할당할 경우 메모리에 참조값을 할당, 다른 변수에 할당할 경우 참조값을 할당

## 원시값

원시값을 재할당할 경우 기존값을 변경할 수 없기 때문에 새로운 메모리 주소에 공간을 확보하고고 재할당할 값을 할당한 뒤 식별자가 참조하던 주소를 재할당할 주소로 변경하는 이유는 변경이 불가능하기 때문이었다

## 문자열 불변성

원시값 저장을 위해 메모리 공간 확보를 위한 크기를 결정해야 한다
ECMAScript 사양에선 문자열타입(2바이트), 숫자 타입(8바이트)를 규정한다
1개의 문자는 2바이트 공간을 차지 따라서 몇개의 문자로 이루어졌냐에 따라 크기 결정

```js
var str = "string";
str[0] = "S";
console.log(str); // string 불변에 의해 바뀌지 않는다. 재할당은 가능
```

```js
var score = 80;

var copy = score; // 값 복사 copy의 80과 score의 80은 다른 주소이다
```

식별자는 값이 들어있는 메모리 주소를 가지고 있다

## 객체

객체는 프로퍼티 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제 가능
프로퍼티 값에도 제한이 없다

## 변경가능한 값

객체 타입의 값은 변경 가능한 값이다.
객체를 할당한 변수가 기억하는 메모리주소를 접근해보면 참조값(메모리 주소)에 접근할 수 있다.

객체 키 식별자가 가진 값은 객체의 실제 값이 시작되는 주소값을 가지고 있다.
만약 프로퍼티 키가 가진 값을 변경할 경우 원시값과 다르게 식별자 주소가 변경되는 것은 아니고 실제 값이 변경된다.

## 얕은 복사와 깊은 복사

```js
const o = { x: { y: 1 } };
// 얕은 복사
const c1 = { ...o };
console.log(c1 === o); // false
console.log(c1.x === o.x); // true

//깊은 복사
const _ = require("lodash");
const c2 = _.cloneDeep(0);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false
```
