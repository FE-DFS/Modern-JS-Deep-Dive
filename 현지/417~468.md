<!-- 25장 -->

# 클래스

클래스: 새로운 객체 생성 메커니즘
클래스를 표현식으로 정의할 수 있으며 이는 일급객체의 특징 중 하나이다. 클래스는 입급 객체로서 다음과 같은 특징이 있다.

1. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
3. 함수의 매개변수에게 전달할 수 있다.
4. 함수의 반환값으로 사용할 수 있다.

클래스 몸체에서 정의할 수 있는 메서드는 constructor, 프로토타입 메서드, 정적 메서드의 세 가지가 있다.

```js
// 클래스 선언문
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name; // name 프로퍼티는 퍼블릭하다.
  }

  // 프로토타입 메서드
  sayHi() {
    console.log(`Hi! My name is ${this.name}`);
  }

  // 정적 메서드
  static sayHello() {
    console.log('Hello');
  }
}

// 인스턴스 생성
const me = new Person('Lee');

// 인스턴스의 프로퍼티 참조
console.log(me.name); // Lee
// 프로토타입 메서드 호출
me.say(); // Hi My name is Lee
// 정적 메서드 호출
Person.sayHello(); // Hello
```

## 클래스 호이스팅

💥 클래스 선언문으로 정의한 클래스

- 함수 선언문과 같이 런타임 이전에 먼저 평가되어 함수 객체를 생성
- 클래스는 생성자 함수로서 호출할 수 있는 함수 constructor 임.
- 함수 객체를 생성하는 시점에 프로토타입도 생성
- 클래스는 클래스 정의 이전에 참조 불가능
- 호이스팅은 발생하지만 let, const와 같이 클래스 선언문 이전에 일시적 사각지대에 빠지기 때문에 호이스팅이 발생하지 않는 것처럼 동작함.

## 인스턴스 생성

- 클래스는 생성자 함수이며 new 연산자와 함께 호출되어 인스턴스를 생성함.
- new 연산자 없이는 타입 에러가 발생

## 메서드

💥 클래스 몸체에서 정의할 수 있는 메서드

- constructor(생성자):

  - 인스턴스를 생성하고 초기화하기 위한 메서드
  - 생성자 함수와 마찬가지로 constructor 내부에서 this에 추가한 프로퍼티는 인스턴스 프로퍼티가 됨.
  - constructor는 메서드로 해석되지 않고 클래스가 평가되어 생성한 함수 객체 코드의 일부가 됨.
  - constructor 생략시 빈 객체를 생성함.
  - 인스턴스를 초기화하려면 constructor를 생략해서는 안됨.
  - constructor 내에서 리턴값을 반환하면 기본 동작을 훼손함.

- 프로토타입 메서드:

  - 클래스 몸체에 정의한 메서드는 기본적으로 프로토타입 메서드

- 정적 메서드:

  - 인스턴스를 생성하지 않아도 호출할 수 있는 메서드
  - static을 붙여서 사용
  - 인스턴스로 호출 불가능. 인스턴스의 프로토타입 체인 상에는 클래스가 존재하지 않기 때문에 인스턴스로 클래스의 정적 메서드를 상속받을 수 없음.
  - 애플리케이션 전역에서 사용할 유틸리티 함수를 전역 함수로 정의하지 않고 메서드로 구조화할 때 유용함.

- 정적 메서드와 프로토타입 메서드의 차이

  1. 정적 메서드와 프로토타입 메서드는 자신이 속해 있는 프로토타입 체인이 다름
  2. 정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출
  3. 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있음.

- 클래스에서 정의한 메서드의 특징
  1. function 키워드를 생략한 메서드 축약 표현을 사용
  2. 객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 콤마 필요없음
  3. 암묵적으로 strict mode로 실행됨
  4. for...in 문이나 Object.keys 등의 메서드 등으로 열거 불가. [[Enumerable]]이 false임.
  5. 내부 메서드 [[Constructor]]를 갖지 않는 non-constructor임. new 연산자와 함께 호출 불가

## 클래스의 인스턴스 생성 과정

new 연산자와 함께 클래스를 호출하면 생성자 함수와 마찬가지로 클래스의 내부 메서드 [[Construct]]가 호출됨.

1. 인스턴스(빈 객체) 생성과 클래스가 생성한 인스턴스에 this 바인딩
2. constructor 내부 코드가 실행되어 this에 바인딩된 인스턴스 초기화
3. 인스턴스가 바인딩된 this 반환

## 프로퍼티

- 인스턴스 프로퍼티:

  - 인스턴스 프로퍼티는 constructor 내부에서 정의해야함

- getter: 인스턴스 프로퍼티에 접근할 때마다 프로퍼티 값을 조작하거나 별도의 행위가 필요할 때 사용
- setter: 인스턴스 프로퍼티에 값을 할당할 때마다 프로퍼티 값을 조작하거나 별도의 행위가 필요할 때 사용

- 클래스 필드 정의 제안:

  - this는 클래스의 constructor와 메서드 내에서만 유효함
  - 클래스 필드에 초기값 할당하지 않으면 undefined
  - 인스턴스 생성시 외부의 초기값을 사용해 초기화하려면 constructor에서 클래스 필드 초기화해야함

- private 필드 정의 제안:
  - #을 붙여서 사용
  - constructor에 정의하면 에러 발생. 클래스 몸체에 정의해야함.

```js
// 클래스 선언문
class Person {
  // private 필드 정의
  #name = '';

  // 생성자
  constructor(name) {
    // private 필드 참조
    this.#name = name;
  }
}

const me = new Person('Lee');

// private 필드는 외부에서 참조 불가
console.log(me.#name); // SyntaxError
```

## 상속에 의한 클래스 확장

- 클래스 상속과 생성자 함수 상속:
  - 상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의하는 것

## super 키워드

💥 동작방식

- super를 호출하면 수퍼클래스의 constructor(super-constructor)를 호출함
- super를 참조하면 수퍼클래스의 메서드를 호출할 수 있음

💥 주의사항

- 서브클래스에서 constructor를 생략하지 않는 경우 서브클래스의 constructor에서는 반드시 super를 호출해야 함
- 서브클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없음
- super는 반드시 서브클래스의 constructor에서만 호출함. 서브클래스가 아닌 클래스의 constructor나 함수에서 super에 호출하면 에러가 발생함.

- 상속 클래스의 인스턴스 생성:
  - 서브클래스는 자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에게 인스턴스 생성을 위임함. 서브클래스의 constructor에서 반드시 super를 호출해야 하는 이유임. 서브클래스는 별도의 인스턴스를 생성하지 않고 super가 반환한 인스턴스를 this에 바인딩하여 그대로 사용함.
